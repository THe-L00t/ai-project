#!/usr/bin/env python3
"""
ÌïòÏù¥Î∏åÎ¶¨Îìú ÎßàÏä§ÌÑ∞ AI Ìä∏Î†àÏù¥Îçî
- Îâ¥Ïä§ Í∞êÏ†ï Î∂ÑÏÑù + Ìå®ÌÑ¥ ÌïôÏäµ + Í≥µÍ≤©Ï†Å Îß§Îß§ + Ï†ÅÏùëÌòï ÌïôÏäµ
- Î™®Îì† AI Í∏∞Îä•ÏùÑ ÌÜµÌï©Ìïú ÏµúÍ∞ï Ìä∏Î†àÏù¥Îî© ÏãúÏä§ÌÖú
"""

import os
import sys
import time
import logging
import asyncio
import numpy as np
import pandas as pd
from datetime import datetime, timedelta
from dotenv import load_dotenv
from collections import deque
import pickle

# ÌîÑÎ°úÏ†ùÌä∏ Í≤ΩÎ°ú Ï∂îÍ∞Ä
sys.path.append(os.path.join(os.path.dirname(__file__), 'src'))
from exchange.UpbitAPI import UpbitAPI

# Ïª¥Ìè¨ÎÑåÌä∏ ÏûÑÌè¨Ìä∏
from news_sentiment_ai import NewsCollector, SentimentAnalyzer
from adaptive_learning_ai import AdaptiveLearningEngine

# Î®∏Ïã†Îü¨Îãù
from sklearn.ensemble import RandomForestRegressor, GradientBoostingRegressor
from sklearn.preprocessing import StandardScaler
from sklearn.metrics import mean_absolute_error

# Î°úÍπÖ ÏÑ§Ï†ï
logging.basicConfig(
    level=logging.INFO,
    format='%(asctime)s - %(levelname)s - %(message)s',
    handlers=[
        logging.StreamHandler(),
        logging.FileHandler('logs/hybrid_master_ai.log')
    ]
)
logger = logging.getLogger(__name__)

class HybridMasterAI:
    """ÌïòÏù¥Î∏åÎ¶¨Îìú ÎßàÏä§ÌÑ∞ AI Ìä∏Î†àÏù¥Îçî"""

    def __init__(self):
        load_dotenv()

        # ÏóÖÎπÑÌä∏ API Ï¥àÍ∏∞Ìôî
        self.upbit = UpbitAPI()

        # Îâ¥Ïä§ Î∂ÑÏÑù Ïª¥Ìè¨ÎÑåÌä∏
        self.news_collector = NewsCollector()
        self.sentiment_analyzer = SentimentAnalyzer()

        # Ï†ÅÏùëÌòï ÌïôÏäµ ÏóîÏßÑ
        self.adaptive_learner = AdaptiveLearningEngine()
        self.adaptive_learner.load_learning_state()
        self.adaptive_learner.initialize_online_models()

        # Í±∞Îûò ÏÑ§Ï†ï (Í≥µÍ≤©Ï†Å)
        self.trading_mode = os.getenv('TRADING_MODE', 'live')
        self.max_position_size = 0.15  # 15% (Í≥µÍ≤©Ï†Å)
        self.stop_loss_percentage = 3.0  # 3% (Í≥µÍ≤©Ï†Å)
        self.take_profit_percentage = 15.0  # 15% (Í≥µÍ≤©Ï†Å)

        # Îß§Îß§ ÏûÑÍ≥ÑÍ∞í (Í≥µÍ≤©Ï†Å)
        self.buy_threshold_change = 1.0  # 1%
        self.sell_threshold_change = -1.0  # -1%
        self.momentum_threshold = 0.5  # 0.5%

        # ÎåÄÏÉÅ ÏΩîÏù∏
        self.target_coins = ['KRW-BTC', 'KRW-ETH', 'KRW-ADA', 'KRW-DOT']

        # Îç∞Ïù¥ÌÑ∞ Ï†ÄÏû•ÏÜå
        self.news_history = deque(maxlen=1000)
        self.price_history = {}
        self.positions = {}
        self.last_prices = {}

        # Ìå®ÌÑ¥ ÌïôÏäµ Î™®Îç∏
        self.pattern_models = {}
        self.pattern_scalers = {}

        # ÏòàÏ∏° Í∏∞Î°ù
        self.pending_predictions = deque(maxlen=1000)

        logger.info("üöÄ ÌïòÏù¥Î∏åÎ¶¨Îìú ÎßàÏä§ÌÑ∞ AI Ìä∏Î†àÏù¥Îçî Ï¥àÍ∏∞Ìôî ÏôÑÎ£å")
        logger.info(f"üí™ Í≥µÍ≤©Ï†Å ÏÑ§Ï†ï: Ìè¨ÏßÄÏÖò {self.max_position_size*100}%, ÏùµÏ†à {self.take_profit_percentage}%, ÏÜêÏ†à {self.stop_loss_percentage}%")

    async def collect_news_and_sentiment(self):
        """Îâ¥Ïä§ ÏàòÏßë Î∞è Í∞êÏ†ï Î∂ÑÏÑù"""
        try:
            logger.info("üì∞ Îâ¥Ïä§ ÏàòÏßë ÏãúÏûë...")

            # ÎπÑÎèôÍ∏∞ Îâ¥Ïä§ ÏàòÏßë
            loop = asyncio.new_event_loop()
            asyncio.set_event_loop(loop)
            articles = loop.run_until_complete(
                self.news_collector.collect_news_async(max_articles=100)
            )
            loop.close()

            # ÏΩîÏù∏Î≥Ñ ÌïÑÌÑ∞ÎßÅ
            filtered_news = self.news_collector.filter_crypto_news(articles)

            # Í∞êÏ†ï Î∂ÑÏÑù
            coin_sentiments = {}
            for coin, news_list in filtered_news.items():
                if news_list:
                    sentiment_results = self.sentiment_analyzer.batch_analyze(news_list)
                    scores = [r['sentiment']['score'] for r in sentiment_results]
                    confidences = [r['sentiment']['confidence'] for r in sentiment_results]

                    coin_sentiments[coin] = {
                        'avg_sentiment': np.mean(scores) if scores else 0.0,
                        'sentiment_strength': np.std(scores) if len(scores) > 1 else 0.0,
                        'avg_confidence': np.mean(confidences) if confidences else 0.0,
                        'news_count': len(news_list),
                        'timestamp': datetime.now()
                    }

            # ÌûàÏä§ÌÜ†Î¶¨Ïóê Ï†ÄÏû•
            self.news_history.append({
                'timestamp': datetime.now(),
                'articles_total': len(articles),
                'coin_sentiments': coin_sentiments
            })

            logger.info(f"‚úÖ Îâ¥Ïä§ Î∂ÑÏÑù ÏôÑÎ£å: {len(articles)}Í∞ú Í∏∞ÏÇ¨")
            return coin_sentiments

        except Exception as e:
            logger.error(f"Îâ¥Ïä§ Î∂ÑÏÑù Ïã§Ìå®: {e}")
            return {}

    def create_hybrid_features(self, market):
        """ÌïòÏù¥Î∏åÎ¶¨Îìú ÌäπÏÑ± ÏÉùÏÑ± (Îâ¥Ïä§ + Ìå®ÌÑ¥ + Í∏∞Ïà†ÏßÄÌëú)"""
        coin = market.split('-')[1]
        features = []

        try:
            # 1. ÌòÑÏû¨ Í∞ÄÍ≤© Îç∞Ïù¥ÌÑ∞
            ticker = self.upbit.GetTicker([market])
            if not ticker:
                return np.array([])

            current_price = ticker[0].trade_price
            change_rate = ticker[0].change_rate * 100
            volume = ticker[0].acc_trade_volume_24h

            # 2. Í∞ÄÍ≤© ÌûàÏä§ÌÜ†Î¶¨ Í¥ÄÎ¶¨
            if market not in self.price_history:
                self.price_history[market] = deque(maxlen=20)

            self.price_history[market].append({
                'price': current_price,
                'timestamp': datetime.now(),
                'change_rate': change_rate,
                'volume': volume
            })

            # 3. Í∏∞Ïà†Ï†Å ÏßÄÌëú ÌäπÏÑ±
            if len(self.price_history[market]) >= 5:
                prices = [h['price'] for h in self.price_history[market]]
                volumes = [h['volume'] for h in self.price_history[market]]

                # Ïù¥ÎèôÌèâÍ∑†
                sma_5 = np.mean(prices[-5:])
                sma_10 = np.mean(prices[-10:]) if len(prices) >= 10 else sma_5

                # Í∞ÄÍ≤© Î™®Î©òÌÖÄ
                price_momentum = (current_price - prices[-5]) / prices[-5] * 100 if len(prices) >= 5 else 0

                # Î≥ºÎ•® Ï∂îÏÑ∏
                volume_trend = (volume - np.mean(volumes[-5:])) / np.mean(volumes[-5:]) * 100 if len(volumes) >= 5 else 0

                # RSI Í∑ºÏÇ¨Ïπò
                price_changes = np.diff(prices[-14:]) if len(prices) >= 14 else np.diff(prices)
                gains = price_changes[price_changes > 0]
                losses = -price_changes[price_changes < 0]
                avg_gain = np.mean(gains) if len(gains) > 0 else 0
                avg_loss = np.mean(losses) if len(losses) > 0 else 0.1
                rsi = 100 - (100 / (1 + avg_gain / avg_loss)) if avg_loss > 0 else 50

                features.extend([
                    change_rate / 100,  # Ï†ïÍ∑úÌôîÎêú Î≥ÄÎèôÎ•†
                    price_momentum / 100,  # Í∞ÄÍ≤© Î™®Î©òÌÖÄ
                    (current_price - sma_5) / sma_5,  # SMA ÎåÄÎπÑ ÏúÑÏπò
                    (sma_5 - sma_10) / sma_10 if sma_10 > 0 else 0,  # SMA Ï∂îÏÑ∏
                    volume_trend / 100,  # Î≥ºÎ•® Ï∂îÏÑ∏
                    (rsi - 50) / 50,  # Ï†ïÍ∑úÌôîÎêú RSI
                ])
            else:
                features.extend([0.0] * 6)

            # 4. Îâ¥Ïä§ Í∞êÏ†ï ÌäπÏÑ±
            recent_sentiment = 0.0
            sentiment_strength = 0.0
            news_count = 0

            if self.news_history and coin in self.news_history[-1]['coin_sentiments']:
                sentiment_data = self.news_history[-1]['coin_sentiments'][coin]
                recent_sentiment = sentiment_data['avg_sentiment']
                sentiment_strength = sentiment_data['sentiment_strength']
                news_count = sentiment_data['news_count']

            features.extend([
                recent_sentiment,
                sentiment_strength,
                min(news_count / 10, 1.0)  # Ï†ïÍ∑úÌôîÎêú Îâ¥Ïä§ Ïàò
            ])

            # 5. Ï†ÅÏùëÌòï ÌïôÏäµ ÌäπÏÑ±
            adaptive_features = self.adaptive_learner.collect_real_time_features(coin)
            if len(adaptive_features) > 0:
                features.extend(adaptive_features[-3:])  # ÎßàÏßÄÎßâ 3Í∞úÎßå ÏÇ¨Ïö©
            else:
                features.extend([0.0] * 3)

            return np.array(features)

        except Exception as e:
            logger.error(f"ÌïòÏù¥Î∏åÎ¶¨Îìú ÌäπÏÑ± ÏÉùÏÑ± Ïã§Ìå® ({market}): {e}")
            return np.array([])

    def get_hybrid_signal(self, market):
        """ÌïòÏù¥Î∏åÎ¶¨Îìú Îß§Îß§ Ïã†Ìò∏ ÏÉùÏÑ± (Î™®Îì† AI Í≤∞Ìï©)"""
        coin = market.split('-')[1]
        signals = []

        try:
            # ÌòÑÏû¨Í∞Ä Ï†ïÎ≥¥
            ticker = self.upbit.GetTicker([market])
            if not ticker:
                return 'HOLD', 0, []

            current_price = ticker[0].trade_price
            change_rate = ticker[0].change_rate * 100

            # 1. Í≥µÍ≤©Ï†Å Ìå®ÌÑ¥ Ïã†Ìò∏
            pattern_signal = self.get_aggressive_pattern_signal(market, current_price, change_rate)
            if pattern_signal != 'HOLD':
                signals.append({
                    'source': 'aggressive_pattern',
                    'signal': pattern_signal,
                    'confidence': 0.7,
                    'reason': f'Í≥µÍ≤©Ï†Å Ìå®ÌÑ¥: {change_rate:+.2f}%'
                })

            # 2. Îâ¥Ïä§ Í∞êÏ†ï Ïã†Ìò∏
            if self.news_history and coin in self.news_history[-1]['coin_sentiments']:
                sentiment_data = self.news_history[-1]['coin_sentiments'][coin]
                sentiment_score = sentiment_data['avg_sentiment']

                if sentiment_score > 0.3:
                    signals.append({
                        'source': 'news_sentiment',
                        'signal': 'BUY',
                        'confidence': min(sentiment_score + 0.3, 1.0),
                        'reason': f'Í∏çÏ†ï Îâ¥Ïä§: {sentiment_score:.2f}'
                    })
                elif sentiment_score < -0.3:
                    signals.append({
                        'source': 'news_sentiment',
                        'signal': 'SELL',
                        'confidence': min(abs(sentiment_score) + 0.3, 1.0),
                        'reason': f'Î∂ÄÏ†ï Îâ¥Ïä§: {sentiment_score:.2f}'
                    })

            # 3. Ï†ÅÏùëÌòï ÌïôÏäµ Ïã†Ìò∏
            if self.adaptive_learner:
                adaptive_prediction = self.adaptive_learner.get_enhanced_prediction(coin)
                if adaptive_prediction and adaptive_prediction['confidence'] > 0.5:
                    predicted_change = adaptive_prediction['predicted_change_pct']

                    if predicted_change > 2.0:
                        signals.append({
                            'source': 'adaptive_learning',
                            'signal': 'BUY',
                            'confidence': adaptive_prediction['confidence'],
                            'reason': f'AI ÏòàÏ∏° ÏÉÅÏäπ: {predicted_change:+.2f}%'
                        })
                    elif predicted_change < -2.0:
                        signals.append({
                            'source': 'adaptive_learning',
                            'signal': 'SELL',
                            'confidence': adaptive_prediction['confidence'],
                            'reason': f'AI ÏòàÏ∏° ÌïòÎùΩ: {predicted_change:+.2f}%'
                        })

            # 4. Ìå®ÌÑ¥ ÌïôÏäµ Î™®Îç∏ Ïã†Ìò∏
            if coin in self.pattern_models:
                features = self.create_hybrid_features(market)
                if len(features) > 0:
                    try:
                        features_scaled = self.pattern_scalers[coin].transform(features.reshape(1, -1))
                        predicted_change = self.pattern_models[coin].predict(features_scaled)[0]

                        if predicted_change > 2.0:
                            signals.append({
                                'source': 'pattern_model',
                                'signal': 'BUY',
                                'confidence': 0.6,
                                'reason': f'Ìå®ÌÑ¥ ÏòàÏ∏° ÏÉÅÏäπ: {predicted_change:+.2f}%'
                            })
                        elif predicted_change < -2.0:
                            signals.append({
                                'source': 'pattern_model',
                                'signal': 'SELL',
                                'confidence': 0.6,
                                'reason': f'Ìå®ÌÑ¥ ÏòàÏ∏° ÌïòÎùΩ: {predicted_change:+.2f}%'
                            })
                    except Exception as e:
                        logger.debug(f"Ìå®ÌÑ¥ Î™®Îç∏ ÏòàÏ∏° Ïã§Ìå®: {e}")

            # 5. Ïã†Ìò∏ ÌÜµÌï© (Í∞ÄÏ§ë Ìà¨Ìëú)
            if not signals:
                return 'HOLD', current_price, []

            buy_weight = sum(s['confidence'] for s in signals if s['signal'] == 'BUY')
            sell_weight = sum(s['confidence'] for s in signals if s['signal'] == 'SELL')

            # Í≥µÍ≤©Ï†Å ÏûÑÍ≥ÑÍ∞í (ÎÇÆÏùÄ Í∏∞Ï§ÄÏúºÎ°ú Í±∞Îûò ÌôúÏÑ±Ìôî)
            min_confidence = 0.3

            if buy_weight > sell_weight and buy_weight >= min_confidence:
                return 'BUY', current_price, [s for s in signals if s['signal'] == 'BUY']
            elif sell_weight > buy_weight and sell_weight >= min_confidence:
                return 'SELL', current_price, [s for s in signals if s['signal'] == 'SELL']
            else:
                return 'HOLD', current_price, signals

        except Exception as e:
            logger.error(f"ÌïòÏù¥Î∏åÎ¶¨Îìú Ïã†Ìò∏ ÏÉùÏÑ± Ïã§Ìå® ({market}): {e}")
            return 'HOLD', 0, []

    def get_aggressive_pattern_signal(self, market, current_price, change_rate):
        """Í≥µÍ≤©Ï†Å Ìå®ÌÑ¥ Ïã†Ìò∏ (Í∏∞Ï°¥ aggressive_trader Î°úÏßÅ)"""
        if market not in self.price_history or len(self.price_history[market]) < 3:
            return 'HOLD'

        # Ïù¥Ï†Ñ Í∞ÄÍ≤©Í≥ºÏùò Î™®Î©òÌÖÄ Í≥ÑÏÇ∞
        if market in self.last_prices:
            prev_price = self.last_prices[market]
            price_momentum = (current_price - prev_price) / prev_price * 100
        else:
            price_momentum = 0

        self.last_prices[market] = current_price

        # Îã®Í∏∞ Ï∂îÏÑ∏ Î∂ÑÏÑù (ÏµúÍ∑º 3Í∞ú Í∞ÄÍ≤©)
        recent_prices = [h['price'] for h in list(self.price_history[market])[-3:]]
        short_term_trend = 0
        if len(recent_prices) >= 3:
            if recent_prices[-1] > recent_prices[0]:
                short_term_trend = 1  # ÏÉÅÏäπ Ï∂îÏÑ∏
            elif recent_prices[-1] < recent_prices[0]:
                short_term_trend = -1  # ÌïòÎùΩ Ï∂îÏÑ∏

        # Í≥µÍ≤©Ï†Å Îß§Îß§ Ï°∞Í±¥
        buy_conditions = [
            change_rate > self.buy_threshold_change,  # 1% ÏÉÅÏäπ
            price_momentum > self.momentum_threshold,  # 0.5% Î™®Î©òÌÖÄ
            short_term_trend >= 0  # ÏÉÅÏäπ ÎòêÎäî Ìö°Î≥¥
        ]

        sell_conditions = [
            change_rate < self.sell_threshold_change,  # -1% ÌïòÎùΩ
            price_momentum < -self.momentum_threshold,  # -0.5% Î™®Î©òÌÖÄ
            short_term_trend <= 0  # ÌïòÎùΩ ÎòêÎäî Ìö°Î≥¥
        ]

        # 2Í∞ú Ïù¥ÏÉÅ Ï°∞Í±¥ ÎßåÏ°±Ïãú Ïã†Ìò∏
        if sum(buy_conditions) >= 2:
            return 'BUY'
        elif sum(sell_conditions) >= 2 and market in self.positions:
            return 'SELL'
        else:
            return 'HOLD'

    def execute_hybrid_trade(self, market, signal, price, reasons):
        """ÌïòÏù¥Î∏åÎ¶¨Îìú Í±∞Îûò Ïã§Ìñâ"""
        coin = market.split('-')[1]

        try:
            if signal == 'BUY' and market not in self.positions:
                # Îß§Ïàò Ïã§Ìñâ
                krw_balance = self.upbit.GetKRWBalance()
                buy_amount = krw_balance * self.max_position_size

                if buy_amount >= 5000:  # ÏµúÏÜå Ï£ºÎ¨∏ Í∏àÏï°
                    if self.trading_mode == 'live':
                        result = self.upbit.BuyMarket(market, buy_amount)
                        if result:
                            quantity = buy_amount / price
                            self.positions[market] = {
                                'type': 'long',
                                'quantity': quantity,
                                'entry_price': price,
                                'timestamp': datetime.now(),
                                'order_uuid': result['uuid'],
                                'reasons': reasons
                            }
                            logger.info(f"üî• [Ïã§Í±∞Îûò] ÌïòÏù¥Î∏åÎ¶¨Îìú Îß§Ïàò: {market} @ {price:,}Ïõê")
                    else:
                        # Î™®ÏùòÍ±∞Îûò
                        quantity = buy_amount / price
                        self.positions[market] = {
                            'type': 'long',
                            'quantity': quantity,
                            'entry_price': price,
                            'timestamp': datetime.now(),
                            'reasons': reasons
                        }
                        logger.info(f"üî• [Î™®Ïùò] ÌïòÏù¥Î∏åÎ¶¨Îìú Îß§Ïàò: {market} @ {price:,}Ïõê")

                    # Ï†ÅÏùëÌòï ÌïôÏäµÏóê Í±∞Îûò Í∏∞Î°ù
                    if self.adaptive_learner:
                        self.adaptive_learner.experience_collector.record_trade(
                            coin=coin,
                            action='BUY',
                            price=price,
                            quantity=quantity
                        )

                    # Ïù¥Ïú† Ï∂úÎ†•
                    for reason in reasons:
                        logger.info(f"   üìä {reason['source']}: {reason['reason']} (Ïã†Î¢∞ÎèÑ: {reason['confidence']:.2f})")

                    return True

            elif signal == 'SELL' and market in self.positions:
                # Îß§ÎèÑ Ïã§Ìñâ
                position = self.positions[market]

                if self.trading_mode == 'live':
                    coin_balance = self.upbit.GetCoinBalance(coin)
                    if coin_balance > 0:
                        result = self.upbit.SellMarket(market, coin_balance)
                        if result:
                            pnl_pct = (price - position['entry_price']) / position['entry_price'] * 100
                            logger.info(f"üî• [Ïã§Í±∞Îûò] ÌïòÏù¥Î∏åÎ¶¨Îìú Îß§ÎèÑ: {market} @ {price:,}Ïõê")
                            logger.info(f"   üí∞ ÏÜêÏùµ: {pnl_pct:+.2f}%")
                else:
                    # Î™®ÏùòÍ±∞Îûò
                    pnl_pct = (price - position['entry_price']) / position['entry_price'] * 100
                    logger.info(f"üî• [Î™®Ïùò] ÌïòÏù¥Î∏åÎ¶¨Îìú Îß§ÎèÑ: {market} @ {price:,}Ïõê")
                    logger.info(f"   üí∞ ÏÜêÏùµ: {pnl_pct:+.2f}%")

                # Ï†ÅÏùëÌòï ÌïôÏäµÏóê Í±∞Îûò Í≤∞Í≥º Í∏∞Î°ù
                if self.adaptive_learner:
                    duration = (datetime.now() - position['timestamp']).total_seconds() / 60
                    self.adaptive_learner.learn_from_trade_outcome(
                        coin=coin,
                        trade_action='BUY',  # ÏõêÎûò Îß§ÏàòÏòÄÎçò Í≤É
                        entry_price=position['entry_price'],
                        exit_price=price,
                        duration_minutes=duration
                    )

                del self.positions[market]

                # Ïù¥Ïú† Ï∂úÎ†•
                for reason in reasons:
                    logger.info(f"   üìä {reason['source']}: {reason['reason']} (Ïã†Î¢∞ÎèÑ: {reason['confidence']:.2f})")

                return True

            return False

        except Exception as e:
            logger.error(f"ÌïòÏù¥Î∏åÎ¶¨Îìú Í±∞Îûò Ïã§Ìñâ Ïã§Ìå®: {e}")
            return False

    def check_risk_management(self):
        """Î¶¨Ïä§ÌÅ¨ Í¥ÄÎ¶¨ (Í≥µÍ≤©Ï†Å ÏÑ§Ï†ï)"""
        for market, position in list(self.positions.items()):
            try:
                ticker = self.upbit.GetTicker([market])
                if not ticker:
                    continue

                current_price = ticker[0].trade_price
                entry_price = position['entry_price']

                # ÏÜêÏùµ Í≥ÑÏÇ∞
                if position['type'] == 'long':
                    pnl_pct = (current_price - entry_price) / entry_price * 100
                else:
                    pnl_pct = (entry_price - current_price) / entry_price * 100

                # ÏÜêÏ†àÎß§ Ï≤¥ÌÅ¨
                if pnl_pct <= -self.stop_loss_percentage:
                    logger.warning(f"üõë ÏÜêÏ†àÎß§ Î∞úÎèô: {market} ({pnl_pct:.2f}%)")
                    self.execute_hybrid_trade(market, 'SELL', current_price, [
                        {'source': 'risk_management', 'signal': 'SELL', 'confidence': 1.0, 'reason': f'ÏÜêÏ†àÎß§ {pnl_pct:.2f}%'}
                    ])

                # ÏùµÏ†àÎß§ Ï≤¥ÌÅ¨
                elif pnl_pct >= self.take_profit_percentage:
                    logger.info(f"üéØ ÏùµÏ†àÎß§ Î∞úÎèô: {market} (+{pnl_pct:.2f}%)")
                    self.execute_hybrid_trade(market, 'SELL', current_price, [
                        {'source': 'risk_management', 'signal': 'SELL', 'confidence': 1.0, 'reason': f'ÏùµÏ†àÎß§ +{pnl_pct:.2f}%'}
                    ])

            except Exception as e:
                logger.error(f"Î¶¨Ïä§ÌÅ¨ Í¥ÄÎ¶¨ Ïò§Î•ò ({market}): {e}")

    def run_hybrid_training(self):
        """ÌïòÏù¥Î∏åÎ¶¨Îìú Î™®Îç∏ Îπ†Î•∏ ÌõàÎ†®"""
        logger.info("üéì ÌïòÏù¥Î∏åÎ¶¨Îìú Ìå®ÌÑ¥ Î™®Îç∏ ÌõàÎ†® ÏãúÏûë...")

        for market in self.target_coins:
            coin = market.split('-')[1]

            try:
                if len(self.price_history.get(market, [])) < 10:
                    logger.warning(f"{coin}: ÌõàÎ†® Îç∞Ïù¥ÌÑ∞ Î∂ÄÏ°±")
                    continue

                # ÌäπÏÑ± Î∞è ÌÉÄÍ≤ü Îç∞Ïù¥ÌÑ∞ ÏÉùÏÑ±
                X = []
                y = []

                history = list(self.price_history[market])
                for i in range(5, len(history) - 1):  # 5Í∞ú Ïù¥ÌõÑÎ∂ÄÌÑ∞ ÏòàÏ∏° Í∞ÄÎä•
                    # Í≥ºÍ±∞ Îç∞Ïù¥ÌÑ∞Î°ú ÌäπÏÑ± ÏÉùÏÑ± (ÏûÑÏãúÎ°ú ÌòÑÏû¨ Î©îÏÜåÎìú ÏÇ¨Ïö©)
                    features = self.create_hybrid_features(market)
                    if len(features) > 0:
                        # Îã§Ïùå ÏãúÏ†êÏùò Î≥ÄÌôîÏú®ÏùÑ ÌÉÄÍ≤üÏúºÎ°ú
                        future_price = history[i + 1]['price']
                        current_price = history[i]['price']
                        change_pct = (future_price - current_price) / current_price * 100

                        X.append(features)
                        y.append(change_pct)

                if len(X) < 5:
                    continue

                X = np.array(X)
                y = np.array(y)

                # Î™®Îç∏ ÏÉùÏÑ± Î∞è ÌõàÎ†®
                model = RandomForestRegressor(n_estimators=50, max_depth=10, random_state=42, n_jobs=-1)
                scaler = StandardScaler()

                X_scaled = scaler.fit_transform(X)
                model.fit(X_scaled, y)

                # Ï†ÄÏû•
                self.pattern_models[coin] = model
                self.pattern_scalers[coin] = scaler

                logger.info(f"‚úÖ {coin} ÌïòÏù¥Î∏åÎ¶¨Îìú Î™®Îç∏ ÌõàÎ†® ÏôÑÎ£å")

            except Exception as e:
                logger.error(f"{coin} Î™®Îç∏ ÌõàÎ†® Ïã§Ìå®: {e}")

    def run_hybrid_cycle(self):
        """ÌïòÏù¥Î∏åÎ¶¨Îìú Îß§Îß§ ÏÇ¨Ïù¥ÌÅ¥ Ïã§Ìñâ"""
        logger.info("üöÄ ÌïòÏù¥Î∏åÎ¶¨Îìú ÎßàÏä§ÌÑ∞ AI Îß§Îß§ ÏãúÏûë!")
        logger.info("=" * 60)
        logger.info("üî• Í≥µÍ≤©Ï†Å ÏÑ§Ï†ï + Îâ¥Ïä§ Í∞êÏ†ï + Ìå®ÌÑ¥ ÌïôÏäµ + Ï†ÅÏùëÌòï AI")
        logger.info("=" * 60)

        cycle_count = 0

        try:
            while True:
                cycle_count += 1
                logger.info(f"\nüîÑ ÌïòÏù¥Î∏åÎ¶¨Îìú Îß§Îß§ ÏÇ¨Ïù¥ÌÅ¥ #{cycle_count}")

                # 1. Îâ¥Ïä§ ÏàòÏßë Î∞è Î∂ÑÏÑù (5Î∂ÑÎßàÎã§)
                if cycle_count % 5 == 1:
                    asyncio.run(self.collect_news_and_sentiment())

                # 2. Ìå®ÌÑ¥ Î™®Îç∏ Ïû¨ÌõàÎ†® (10Î∂ÑÎßàÎã§)
                if cycle_count % 10 == 1:
                    self.run_hybrid_training()

                # 3. ÌòÑÏû¨ ÏûîÍ≥† ÌôïÏù∏
                krw_balance = self.upbit.GetKRWBalance()
                logger.info(f"üí∞ ÏõêÌôî ÏûîÍ≥†: {krw_balance:,.0f}Ïõê")

                # 4. Í∞Å ÏΩîÏù∏Î≥Ñ ÌïòÏù¥Î∏åÎ¶¨Îìú Ïã†Ìò∏ ÌôïÏù∏ Î∞è Í±∞Îûò
                for market in self.target_coins:
                    try:
                        signal, price, reasons = self.get_hybrid_signal(market)

                        if signal != 'HOLD':
                            logger.info(f"üéØ {market}: {signal} Ïã†Ìò∏ (Í∞ÄÍ≤©: {price:,}Ïõê)")
                            self.execute_hybrid_trade(market, signal, price, reasons)
                        else:
                            logger.info(f"‚è∏Ô∏è  {market}: HOLD (Í∞ÄÍ≤©: {price:,}Ïõê)")

                    except Exception as e:
                        logger.error(f"{market} Ï≤òÎ¶¨ Ïò§Î•ò: {e}")

                # 5. Î¶¨Ïä§ÌÅ¨ Í¥ÄÎ¶¨
                self.check_risk_management()

                # 6. Ï†ÅÏùëÌòï ÌïôÏäµ ÏóÖÎç∞Ïù¥Ìä∏ (15Î∂ÑÎßàÎã§)
                if cycle_count % 15 == 0 and self.adaptive_learner:
                    self.adaptive_learner.continuous_learning_cycle()
                    self.adaptive_learner.save_learning_state()

                # 7. ÌòÑÏû¨ Ìè¨ÏßÄÏÖò ÏÉÅÌÉú Ï∂úÎ†•
                if self.positions:
                    logger.info("üìä ÌòÑÏû¨ Ìè¨ÏßÄÏÖò:")
                    for market, pos in self.positions.items():
                        ticker = self.upbit.GetTicker([market])
                        if ticker:
                            current_price = ticker[0].trade_price
                            pnl_pct = (current_price - pos['entry_price']) / pos['entry_price'] * 100
                            duration = datetime.now() - pos['timestamp']
                            logger.info(f"   {market}: {pos['quantity']:.8f} ({pnl_pct:+.2f}%, {duration})")
                else:
                    logger.info("üìä ÌòÑÏû¨ Ìè¨ÏßÄÏÖò: ÏóÜÏùå")

                # 8. 20Ï¥à ÎåÄÍ∏∞ (Í≥µÍ≤©Ï†Å ÏÇ¨Ïù¥ÌÅ¥)
                logger.info("‚è±Ô∏è  20Ï¥à ÎåÄÍ∏∞...")
                time.sleep(20)

        except KeyboardInterrupt:
            logger.info("\\nüõë ÏÇ¨Ïö©ÏûêÏóê ÏùòÌïú Ï†ïÏßÄ")
        except Exception as e:
            logger.error(f"‚ùå ÏπòÎ™ÖÏ†Å Ïò§Î•ò: {e}")
        finally:
            # ÌïôÏäµ ÏÉÅÌÉú Ï†ÄÏû•
            if self.adaptive_learner:
                self.adaptive_learner.save_learning_state()
            logger.info("üèÅ ÌïòÏù¥Î∏åÎ¶¨Îìú ÎßàÏä§ÌÑ∞ AI Îß§Îß§ Ï¢ÖÎ£å")

def main():
    """Î©îÏù∏ Ìï®Ïàò"""
    print("üöÄ Hybrid Master AI Trader")
    print("=" * 50)
    print("üî• Í≥µÍ≤©Ï†Å Îß§Îß§ + Îâ¥Ïä§ Í∞êÏ†ï + Ìå®ÌÑ¥ ÌïôÏäµ + Ï†ÅÏùëÌòï AI")
    print("=" * 50)

    try:
        ai = HybridMasterAI()
        ai.run_hybrid_cycle()
    except Exception as e:
        logger.error(f"ÌïòÏù¥Î∏åÎ¶¨Îìú AI Ïã§Ìñâ Ïã§Ìå®: {e}")
        return 1

    return 0

if __name__ == "__main__":
    sys.exit(main())